# -*- coding: utf-8 -*-
"""RS Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tuo0nTMlrchpnBqZRIHwg-EuMtPAq7S8
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **DATA PROCESSING**"""

import pandas as pd

# Example path, change it to match where your dataset is located
df = pd.read_csv('/content/drive/MyDrive/RS/SpotifyFeatures.csv')  # Update path accordingly

# Check the first few rows of the dataset
df.head()

import seaborn as sns
import matplotlib.pyplot as plt

df.info()

# Summary statistics
df.describe()

# Check for missing values
df.isnull().sum()

# Distribution of popularity
sns.histplot(df['popularity'], bins=30)
plt.title('Distribution of Popularity')
plt.show()

missing_tracks = df[df['track_name'].isnull()]
print(missing_tracks)

df = df.dropna(subset=['track_name'])

missing_tracks = df[df['track_name'].isnull()]
print(missing_tracks)

print(df.isnull().sum())  # Check for missing values
print(df.shape)  # Check the number of rows and columns

print(df.columns)

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import StandardScaler

# Select relevant features for similarity calculation
features = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness',
            'loudness', 'speechiness', 'tempo', 'valence']
X = df[features]

# Standardize the features (scaling is important for cosine similarity)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Compute cosine similarity between all tracks
cosine_sim = cosine_similarity(X_scaled)

# Function to recommend tracks based on track id
def recommend_tracks(track_id, cosine_sim, df):
    idx = df[df['track_id'] == track_id].index[0]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    recommended_tracks = []
    for i in sim_scores[1:6]:  # Get top 5 recommendations
        recommended_tracks.append(df['track_name'].iloc[i[0]])

    return recommended_tracks

# Take a smaller subset (e.g., the first 1000 rows) for testing
df_subset = df.head(1000)

"""RECOMMENDATION"""

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import StandardScaler

# Select relevant features for similarity calculation
features = ['acousticness', 'danceability', 'energy', 'instrumentalness', 'liveness',
            'loudness', 'speechiness', 'tempo', 'valence']

# Subset data for testing
X = df_subset[features]

# Standardize the features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Compute cosine similarity
cosine_sim = cosine_similarity(X_scaled)

def get_song_recommendations(song_name, cosine_sim, df):
    # Get the index of the song that matches the name
    idx = df[df['track_name'] == song_name].index[0]

    # Get the pairwise similarity scores for all songs
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort the songs based on the similarity score
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the top 10 most similar songs (excluding the song itself)
    sim_scores = sim_scores[1:11]

    # Get the song indices
    song_indices = [i[0] for i in sim_scores]

    # Return the top 10 most similar songs
    return df['track_name'].iloc[song_indices]

print(df['track_name'].head(20))  # Show the first 20 song names

song_name = 'Veunise'  # Replace with any song name from your dataset
recommendations = get_song_recommendations(song_name, cosine_sim, df)
print(f"Recommendations for '{song_name}':")
print(recommendations)

"""**PLAYLIST**

"""

def generate_playlist(song_name, cosine_sim, df, top_n=10):
    # Normalize the song name
    normalized_song_name = normalize_text(song_name)

    if normalized_song_name in df['normalized_track_name'].values:
        song_idx = df[df['normalized_track_name'] == normalized_song_name].index[0]

        # Get the cosine similarity for the song
        sim_scores = list(enumerate(cosine_sim[song_idx]))

        # Sort the songs based on similarity scores
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Get the top n songs
        top_songs = [i[0] for i in sim_scores[1:top_n+1]]  # Exclude the song itself

        # Return the top recommended songs
        recommended_tracks = df.iloc[top_songs][['track_name', 'artist_name']]
        return recommended_tracks
    else:
        return "Song not found in dataset."

# Example usage:
song_name = 'Veunise'  # Replace with the song you want recommendations for
playlist = generate_playlist(song_name, cosine_sim, df, top_n=10)
print(f"Generated Playlist for '{song_name}':")
print(playlist)

"""**UI**"""

!pip install streamlit

import streamlit as st

# Title of the app
st.title("Music Recommender System")

# Input: Song name
song_name = st.text_input("Enter a song name to get recommendations:")

if song_name:
    # Get recommendations
    recommendations = generate_playlist(song_name, cosine_sim, df, top_n=10)

    # Show the recommendations
    if isinstance(recommendations, str):
        st.write(recommendations)
    else:
        st.write(f"Recommended songs similar to '{song_name}':")
        st.write(recommendations)

